# frozen_string_literal: true

require 'spec_helper'
require 'pry'

RSpec.describe Amoeba::Config, '#has_one' do
  subject(:duplicate) { original.amoeba_dup }

  context 'with has_one association' do
    let(:parent_config) do
      <<~CONFIG
        has_one :child

        amoeba { enable }
      CONFIG
    end
    let(:child_config) do
      <<~CONFIG
        amoeba { append name: ' (dup)' }
      CONFIG
    end

    before do
      ActiveRecord::Base.connection.drop_table :parents, if_exists: true
      ActiveRecord::Base.connection.drop_table :children, if_exists: true
      # schema_cache.clear! may not be required with 6.1+
      ActiveRecord::Base.connection.schema_cache.clear!
      ActiveRecord::Base.connection.create_table :parents
      ActiveRecord::Base.connection.create_table :children do |t|
        t.references :parent
        t.string :name
      end

      stub_const 'Parent', Class.new(ActiveRecord::Base)
      stub_const 'Child', Class.new(ActiveRecord::Base)

      Parent.class_eval(parent_config)
      Child.class_eval(child_config)
    end

    context 'with a single child record' do
      let(:original) { Parent.create(child: Child.new(name: 'Fred')) }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(original.child.name).to eq 'Fred' }
      it { expect(duplicate.child.name).to eq 'Fred (dup)' }
    end

    context 'without child record' do
      let(:original) { Parent.create }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with nullify preprocessing' do
      let(:original) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            nullify :child
          end
        CONFIG
      end

      before do
        pending 'TODO: Decide if this is the desired behaviour'
        # It seems sensible that nullify should work on a has_one association
        # but at the moment it results in an ActiveModel::MissingAttributeError
        # exception.
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with a duplicate child record generated by preprocessing' do
      let(:original) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            customize(
              lambda do |original, copy|
                copy.child = Child.new(name: 'Eric')
              end
            )
          end
        CONFIG
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(duplicate.child.name).to eq 'Eric' }
    end

    context 'with has_many not recognized' do
      let(:original) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            recognize [:has_many, :has_and_belongs_to_many]
          end
        CONFIG
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it do
        duplicate.save
        expect(duplicate.child).to be_nil
      end
    end
  end

  context 'with has_one/through association' do
    let(:duplicate) { original.amoeba_dup }
    let(:original) do
      Parent.create(
        child: Child.new(
          grandchild: Grandchild.new(name: 'Grandchild')
        )
      )
    end
    let(:parent_config) do
      <<~CONFIG
        has_one :child
        has_one :grandchild, through: :child

        amoeba { enable }
      CONFIG
    end
    let(:child_config) do
      <<~CONFIG
        belongs_to :parent
        has_one :grandchild

        amoeba { enable }
      CONFIG
    end
    let(:grandchild_config) do
      <<~CONFIG
        belongs_to :child

        amoeba { append name: ' (dup)' }
      CONFIG
    end

    before do
      ActiveRecord::Base.connection.drop_table :parents, if_exists: true
      ActiveRecord::Base.connection.drop_table :children, if_exists: true
      ActiveRecord::Base.connection.drop_table :grandchildren, if_exists: true
      # schema_cache.clear! may not be required with 6.1+
      ActiveRecord::Base.connection.schema_cache.clear!
      ActiveRecord::Base.connection.create_table :parents
      ActiveRecord::Base.connection.create_table :children do |t|
        t.references :parent
      end
      ActiveRecord::Base.connection.create_table :grandchildren do |t|
        t.references :child
        t.string :name
      end

      stub_const 'Parent', Class.new(ActiveRecord::Base)
      stub_const 'Child', Class.new(ActiveRecord::Base)
      stub_const 'Grandchild', Class.new(ActiveRecord::Base)
      Parent.class_eval parent_config
      Child.class_eval child_config
      Grandchild.class_eval grandchild_config
    end

    it 'creates a new grandchild record' do
      duplicate
      expect { duplicate.save }.to change(Grandchild, :count).by 1
    end

    it 'duplicates the grandchild' do
      duplicate.save
      expect(duplicate.grandchild.name).to eq 'Grandchild (dup)'
    end

    context 'with has_one not recognized on child table' do
      before do
        Child.class_eval <<~CONFIG, __FILE__, __LINE__ + 1
          amoeba { recognize [:has_many, :has_and_belongs_to_many] }
        CONFIG
      end

      it 'does create new child record' do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it 'does not creates new grandchild record' do
        duplicate
        expect { duplicate.save }.not_to change(Grandchild, :count)
      end

      it 'does include grandchild models in the duplicate' do
        duplicate.save
        expect(duplicate.grandchild).to be_nil
      end
    end

    context 'without amoeba enabled on the child table' do
      let(:child_config) do
        <<~CONFIG
          belongs_to :parent
          has_one :grandchild
        CONFIG
      end

      it 'does create new child record' do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it 'does not creates new grandchild record' do
        duplicate
        expect { duplicate.save }.not_to change(Grandchild, :count)
      end

      it 'does include grandchild models in the duplicate' do
        duplicate.save
        expect(duplicate.grandchild).to be_nil
      end
    end
  end
end
