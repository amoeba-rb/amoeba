# frozen_string_literal: true

require 'spec_helper'
require 'pry'

RSpec.describe Amoeba::Config, '#has_one' do
  context 'with has_one association' do
    subject(:duplicate) { record.amoeba_dup }

    let(:parent_config) do
      <<~CONFIG
        has_one :child

        amoeba { enable }
      CONFIG
    end
    let(:child_config) do
      <<~CONFIG
        amoeba { append name: ' (dup)' }
      CONFIG
    end

    before do
      ActiveRecord::Base.connection.drop_table :parents, if_exists: true
      ActiveRecord::Base.connection.drop_table :children, if_exists: true
      # schema_cache.clear! may not be required with 6.1+
      ActiveRecord::Base.connection.schema_cache.clear!
      ActiveRecord::Base.connection.create_table :parents
      ActiveRecord::Base.connection.create_table :children do |t|
        t.references :parent
        t.string :name
      end

      stub_const 'Parent', Class.new(ActiveRecord::Base)
      stub_const 'Child', Class.new(ActiveRecord::Base)

      Parent.class_eval(parent_config)
      Child.class_eval(child_config)
    end

    context 'with a single child record' do
      let(:record) { Parent.create(child: Child.new(name: 'Fred')) }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(record.child.name).to eq 'Fred' }
      it { expect(duplicate.child.name).to eq 'Fred (dup)' }
    end

    context 'without child record' do
      let(:record) { Parent.create }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with nullify preprocessing' do
      let(:record) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            nullify :child
          end
        CONFIG
      end

      before do
        pending 'TODO: Decide if this is the desired behaviour'
        # It seems sensible that nullify should work on a has_one association
        # but at the moment it results in an ActiveModel::MissingAttributeError
        # exception.
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with a duplicate child record generated by preprocessing' do
      let(:record) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            customize(
              lambda do |original, copy|
                copy.child = Child.new(name: 'Eric')
              end
            )
          end
        CONFIG
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(duplicate.child.name).to eq 'Eric' }
    end

    context 'with has_many not recognized' do
      let(:record) { Parent.create(child: Child.new) }
      let(:parent_config) do
        <<~CONFIG
          has_one :child

          amoeba do
            enable
            recognize [:has_many, :has_and_belongs_to_many]
          end
        CONFIG
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it do
        duplicate.save
        expect(duplicate.child).to be_nil
      end
    end
  end
end
