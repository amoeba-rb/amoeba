# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Amoeba::Config, '#has_one' do
  subject(:duplicate) { original.amoeba_dup }

  before do
    tables.each_key { |table| ActiveRecord::Base.connection.drop_table table, if_exists: true }
    # schema_cache.clear! may not be required with 6.1+
    ActiveRecord::Base.connection.schema_cache.clear!

    tables.each_pair do |table, config|
      ActiveRecord::Base.connection.create_table(table, &(config[:database])) if config[:database]
      stub_const config[:model], Class.new(Class.const_get(config[:parent_model]))
      Class.const_get(config[:model]).class_eval(config[:model_config])
    end
  end

  context 'with has_one association' do
    let(:tables) do
      {
        parents: {
          database: proc {},
          model: 'Parent',
          parent_model: 'ActiveRecord::Base',
          model_config: <<~CONFIG
            has_one :child
            amoeba { enable }
          CONFIG
        },
        children: {
          database: proc do |t|
            t.references :parent
            t.string :name
          end,
          model: 'Child',
          parent_model: 'ActiveRecord::Base',
          model_config: "amoeba { append name: ' (dup)' }"
        }
      }
    end

    context 'with a single child record' do
      let(:original) { Parent.create(child: Child.new(name: 'Fred')) }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(original.child.name).to eq 'Fred' }
      it { expect(duplicate.child.name).to eq 'Fred (dup)' }
    end

    context 'without amoeba enabled' do
      let(:original) { Parent.create(child: Child.new(name: 'Fred')) }
      let(:tables) { super().tap { |t| t[:parents][:model_config] = 'has_one :child' } }

      it { expect(duplicate.child).to be_nil }
    end

    context 'without child record' do
      let(:original) { Parent.create }

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with nullify preprocessing' do
      let(:original) { Parent.create(child: Child.new) }
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            has_one :child

            amoeba do
              enable
              nullify :child
            end
          CONFIG
        end
      end

      before do
        pending 'TODO: Decide if this is the desired behaviour'
        # It seems sensible that nullify should work on a has_one association
        # but at the moment it results in an ActiveModel::MissingAttributeError
        # exception.
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with a duplicate child record generated by preprocessing' do
      let(:original) { Parent.create(child: Child.new) }
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            has_one :child

            amoeba do
              enable
              customize(
                lambda do |original, copy|
                  copy.child = Child.new(name: 'Eric')
                end
              )
            end
          CONFIG
        end
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(duplicate.child.name).to eq 'Eric' }
    end

    context 'with has_many not recognized' do
      let(:original) { Parent.create(child: Child.new) }
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            has_one :child

            amoeba do
              enable
              recognize [:has_many, :has_and_belongs_to_many]
            end
          CONFIG
        end
      end

      it { is_expected.to be_valid }

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it do
        duplicate.save
        expect(duplicate.child).to be_nil
      end
    end
  end

  context 'with single table inheritance' do
    let(:original) { SuperParent.create(child: Child.new(name: 'Fred')) }
    let(:tables) do
      {
        parents: {
          database: proc { |t| t.string :type },
          model: 'Parent',
          parent_model: 'ActiveRecord::Base',
          model_config: <<~CONFIG
            has_one :child
            amoeba { enable }
          CONFIG
        },
        children: {
          database: proc do |t|
            t.references :parent
            t.string :name
          end,
          model: 'Child',
          parent_model: 'ActiveRecord::Base',
          model_config: "amoeba { append name: ' (dup)' }"
        },
        super_parents: {
          model: 'SuperParent',
          parent_model: 'Parent',
          model_config: ''
        }
      }
    end

    context 'with propagate' do
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            has_one :child

            amoeba {
              enable
              propagate
            }
          CONFIG
        end
      end

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(duplicate.child.name).to eq 'Fred (dup)' }
    end

    context 'without propagate' do
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            has_one :child

            amoeba { enable }
          CONFIG
        end
      end

      it do
        duplicate
        expect { duplicate.save }.not_to change(Child, :count)
      end

      it { expect(duplicate.child).to be_nil }
    end

    context 'with child associated to inherited table' do
      let(:tables) do
        super().tap do |t|
          t[:parents][:model_config] = <<~CONFIG
            amoeba {
              enable
              propagate
            }
          CONFIG
          t[:super_parents][:model_config] = 'has_one :child, foreign_key: :parent_id'
        end
      end

      it do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it { expect(duplicate.child.name).to eq 'Fred (dup)' }
    end
  end

  context 'with has_one/through association' do
    let(:duplicate) { original.amoeba_dup }
    let(:original) do
      Parent.create(
        child: Child.new(
          grandchild: Grandchild.new(name: 'Grandchild')
        )
      )
    end
    let(:tables) do
      {
        parents: {
          database: proc {},
          model: 'Parent',
          parent_model: 'ActiveRecord::Base',
          model_config: <<~CONFIG
            has_one :child
            has_one :grandchild, through: :child

            amoeba { enable }
          CONFIG
        },
        children: {
          database: proc do |t|
            t.references :parent
          end,
          model: 'Child',
          parent_model: 'ActiveRecord::Base',
          model_config: <<~CONFIG
            belongs_to :parent
            has_one :grandchild

            amoeba { enable }
          CONFIG
        },
        grandchildren: {
          database: proc do |t|
            t.references :child
            t.string :name
          end,
          model: 'Grandchild',
          parent_model: 'ActiveRecord::Base',
          model_config: <<~CONFIG
            belongs_to :child

            amoeba { append name: ' (dup)' }
          CONFIG
        }
      }
    end

    it 'creates a new grandchild record' do
      duplicate
      expect { duplicate.save }.to change(Grandchild, :count).by 1
    end

    it 'duplicates the grandchild' do
      duplicate.save
      expect(duplicate.grandchild.name).to eq 'Grandchild (dup)'
    end

    context 'with has_one not recognized on child table' do
      let(:tables) do
        super().tap do |t|
          t[:children][:model_config] = <<~CONFIG
            belongs_to :parent
            has_one :grandchild

            amoeba {
              enable
              recognize [:has_many, :has_and_belongs_to_many]
            }
          CONFIG
        end
      end

      it 'does create new child record' do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it 'does not creates new grandchild record' do
        duplicate
        expect { duplicate.save }.not_to change(Grandchild, :count)
      end

      it 'does include grandchild models in the duplicate' do
        duplicate.save
        expect(duplicate.grandchild).to be_nil
      end
    end

    context 'without amoeba enabled on the child table' do
      let(:tables) do
        super().tap do |t|
          t[:children][:model_config] = <<~CONFIG
            belongs_to :parent
            has_one :grandchild
          CONFIG
        end
      end

      it 'does create new child record' do
        duplicate
        expect { duplicate.save }.to change(Child, :count).by 1
      end

      it 'does not creates new grandchild record' do
        duplicate
        expect { duplicate.save }.not_to change(Grandchild, :count)
      end

      it 'does include grandchild models in the duplicate' do
        duplicate.save
        expect(duplicate.grandchild).to be_nil
      end
    end
  end
end
